###
### PROXY HTTP-Config generated with capistrano at: <%= Time.now.strftime("%Y-%m-%d .. %H:%M .. %Z") %>
### Application: <%= fetch(:application) %>, Stage: <%= fetch(:stage) %>
### Site Name: <%= fetch(:nginx_proxy_site_name) %>
### Upstream App: <%= fetch(:nginx_upstream_app_host) %>:<%= fetch(:nginx_upstream_app_port) %>
###

<% if fetch(:nginx_use_ssl) %>
# Redirect HTTP to HTTPS
server {
  listen 80;
  listen [::]:80;

  server_name <%= nginx_all_domains_with_www.join(joiner) %>;

  <% if fetch(:allow_well_known_proxy) %>
  # For Certbot ACME Challenge
  location ~ /.well-known {
    allow all;
    root <%= fetch(:nginx_proxy_well_known_root) %>; # Pfad für Certbot auf dem Proxy
  }
  <% end %>

  location / {
    <% if fetch(:nginx_major_domain) %>
    return 301 https://<%= nginx_major_domain %>$request_uri;
    <% else %>
    return 301 https://$host$request_uri;
    <% end %>
  }
}
<% end %>


<% if fetch(:nginx_major_domain) && !nginx_domains.empty? %>
<% if fetch(:nginx_use_ssl) %>
# Redirect old domains to major (HTTPS)
server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;

  ssl_certificate       <%= fetch(:nginx_other_ssl_cert) %>;
  ssl_certificate_key   <%= fetch(:nginx_other_ssl_key) %>;

  <%= render2go("nginx/https_ssl_options") %> # Dein SSL Options Partial

  server_name           <%= nginx_domains.join(joiner) %>;
  return 301 https://<%= nginx_major_domain %>$request_uri;
}
<% else %>
# Redirect old domains to major (HTTP)
server {
  listen 80;
  listen [::]:80;

  server_name           <%= nginx_domains.join(joiner) %>;
  return 301 http://<%= nginx_major_domain %>$request_uri;
}
<% end %>
<% end %>


<% if fetch(:nginx_use_ssl) %>
# Main SSL Server Block for Proxy
server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;

  ssl_certificate     <%= fetch(:nginx_ssl_cert) %>;
  ssl_certificate_key <%= fetch(:nginx_ssl_key) %>;

  <%= render2go("nginx/https_ssl_options") %> # Dein SSL Options Partial
<% else %>
# Main HTTP Server Block for Proxy
server {
  listen 80;
  listen [::]:80;
<% end %>

  <% if fetch(:nginx_remove_www) %>
  ## Remove "www" from URLs
  if ($host ~* ^www\.(?<domain>.*)) {
    return 301 <%= fetch(:nginx_use_ssl) ? "https" : "http" %>://$domain$request_uri;
  }
  <% end %>

  <% if fetch(:nginx_major_domain) %>
  server_name <%= fetch(:nginx_major_domain).gsub(/^\*?\./, "") %>;
  <% else %>
  server_name <%= nginx_domains_with_www.join(joiner) %>;
  <% end %>

  # Logging für den Proxy
  access_log <%= fetch(:nginx_proxy_log_folder) %>/<%= fetch(:nginx_proxy_site_name) %>-access.log;
  error_log  <%= fetch(:nginx_proxy_log_folder) %>/<%= fetch(:nginx_proxy_site_name) %>-error.log;

  <%# For Certbot ACME Challenge (falls direkt auf Port 443/80 ohne vorherigen Redirect) %>
  <% if fetch(:allow_well_known_proxy) %>
  location ~ /.well-known {
    allow all;
    root <%= fetch(:nginx_proxy_well_known_root) %>; # Pfad für Certbot auf dem Proxy
  }
  <% end %>



  # Proxying to the App Server
  location / {
    # proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade"; # Für WebSockets, falls benötigt
    proxy_read_timeout 90; # Beispiel
    proxy_set_header Host               $host:$server_port;
    proxy_redirect    off;
    proxy_pass http://<%= fetch(:nginx_upstream_app_host) %>:<%= fetch(:nginx_upstream_app_port) %>;
  }
}